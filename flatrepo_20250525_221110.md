---
repository:
  name: rocket-bot-legacy
  owner: unknown
  url: ""
generated:
  timestamp: 2025-05-26T03:11:10.420Z
  tool: FlatRepo
statistics:
  totalFiles: 9
  totalLines: 778
  languages:
    javascript: 6
    json: 2
  fileTypes:
    .js: 6
    .json: 2
    .example: 1
---

===  rocketchat-config.js
```javascript
// rocketchat-config.js
module.exports = {
  /**
   * Configuraci√≥n personalizada para el adaptador de Rocket.Chat
   * con soporte para Livechat
   */
  parseRoomIdFromMessage: function (message) {
    // El objeto message debe contener una referencia al roomType
    if (message && message.user && message.user.roomType === "l") {
      // Manejar mensajes de livechat
      return {
        roomId: message.user.roomId,
        isLivechat: true,
        roomType: "l", // Agregar esta l√≠nea
      };
    }

    // Comportamiento normal para mensajes regulares
    return {
      roomId: message.user.roomId,
      isLivechat: false,
      roomType: message.user.roomType || "c", // Agregar esta l√≠nea
    };
  },

  // Opciones adicionales para el adaptador
  integrationId: "hubot",
  botName: "hubot",
  livechatEnabled: true,
};
```
=== EOF: rocketchat-config.js

===  package.json
```json
{
  "name": "rocket-bot-legacy",
  "version": "1.0.0",
  "description": "Bot de Rocket.Chat con soporte para Livechat",
  "main": "index.js",
  "scripts": {
    "start": "node -r dotenv/config node_modules/hubot/bin/hubot.js -a rocketchat --require ./rocketchat-config.js"
  },
  "keywords": [
    "rocketchat",
    "hubot",
    "bot",
    "livechat"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "coffeescript": "^2.7.0",
    "dotenv": "^16.1.4",
    "hubot": "^3.3.2",
    "hubot-rocketchat": "^2.0.0",
    "openai": "^4.97.0"
  }
}
```
=== EOF: package.json

===  external-scripts.json
```json
[]
```
=== EOF: external-scripts.json

===  .env.example
```
# Credenciales de Rocket.Chat
ROCKETCHAT_URL=http://localhost:3000
ROCKETCHAT_USER=
ROCKETCHAT_PASSWORD=
ROCKETCHAT_ROOM=
RESPOND_TO_DM=
RESPOND_TO_EDITED=

# Configuraci√≥n de Hubot
PORT=3001
HUBOT_LOG_LEVEL=debug
# re_D7erVVJK_D2a9AQx8UMt1f231N4MynM2o
```
=== EOF: .env.example

===  src/document-processor.js
```javascript
/**
 * M√≥dulo para procesar documentos y extraer informaci√≥n relevante
 * para entrenar al bot con contexto espec√≠fico
 */

const fs = require('fs');
const path = require('path');
const OpenAI = require("openai");

// Configuraci√≥n de DeepSeek AI
const openai = new OpenAI({
  baseURL: "https://api.deepseek.com",
  apiKey: "sk-da937a8a5a2c4aea948dfca4d97d9a3f",
});

// Almacenamiento en memoria para documentos cargados
const documentStore = {
  documents: {},
  embeddings: {},
};

/**
 * Carga un documento en el almacenamiento
 * @param {string} documentPath - Ruta al documento
 * @param {string} documentName - Nombre identificativo del documento
 * @returns {Promise<boolean>} - √âxito de la operaci√≥n
 */
async function loadDocument(documentPath, documentName) {
  try {
    // Verificar que el archivo existe
    if (!fs.existsSync(documentPath)) {
      throw new Error(`El documento no existe en la ruta: ${documentPath}`);
    }

    // Leer el contenido del documento
    const content = fs.readFileSync(documentPath, 'utf8');
    
    // Guardar el documento en el almacenamiento
    documentStore.documents[documentName] = {
      content,
      path: documentPath,
      loadedAt: new Date().toISOString(),
    };

    // Generar embeddings para b√∫squeda sem√°ntica
    await generateEmbeddings(documentName);

    return true;
  } catch (error) {
    console.error(`Error al cargar el documento ${documentName}:`, error);
    return false;
  }
}

/**
 * Genera embeddings para un documento cargado
 * @param {string} documentName - Nombre del documento
 * @returns {Promise<void>}
 */
async function generateEmbeddings(documentName) {
  try {
    const document = documentStore.documents[documentName];
    if (!document) {
      throw new Error(`Documento no encontrado: ${documentName}`);
    }

    // Dividir el documento en chunks para procesar
    const chunks = splitDocumentIntoChunks(document.content);
    
    // Almacenar los chunks y sus embeddings
    documentStore.embeddings[documentName] = [];
    
    for (const [index, chunk] of chunks.entries()) {
      // En una implementaci√≥n real, aqu√≠ se generar√≠an embeddings con la API
      // Por ahora, simulamos el proceso para no consumir tokens innecesarios
      documentStore.embeddings[documentName].push({
        chunk,
        index,
        // En producci√≥n: embedding = await openai.embeddings.create(...)
      });
    }
    
    console.log(`Embeddings generados para el documento: ${documentName}`);
  } catch (error) {
    console.error(`Error al generar embeddings para ${documentName}:`, error);
  }
}

/**
 * Divide un documento en chunks m√°s peque√±os para procesamiento
 * @param {string} content - Contenido del documento
 * @param {number} maxChunkSize - Tama√±o m√°ximo de cada chunk
 * @returns {Array<string>} - Array de chunks
 */
function splitDocumentIntoChunks(content, maxChunkSize = 1000) {
  const paragraphs = content.split('\n\n');
  const chunks = [];
  let currentChunk = '';
  
  for (const paragraph of paragraphs) {
    if ((currentChunk + paragraph).length <= maxChunkSize) {
      currentChunk += (currentChunk ? '\n\n' : '') + paragraph;
    } else {
      if (currentChunk) {
        chunks.push(currentChunk);
      }
      currentChunk = paragraph;
    }
  }
  
  if (currentChunk) {
    chunks.push(currentChunk);
  }
  
  return chunks;
}

/**
 * Busca informaci√≥n relevante en los documentos cargados
 * @param {string} query - Consulta del usuario
 * @param {string} documentName - Nombre del documento (opcional)
 * @returns {Promise<string>} - Contexto relevante encontrado
 */
async function searchInDocuments(query, documentName = null) {
  try {
    // Si se especifica un documento, buscar solo en ese
    if (documentName && documentStore.documents[documentName]) {
      return searchInSpecificDocument(query, documentName);
    }
    
    // Si no se especifica, buscar en todos los documentos cargados
    let allResults = [];
    for (const docName of Object.keys(documentStore.documents)) {
      const result = await searchInSpecificDocument(query, docName);
      if (result) {
        allResults.push(`De ${docName}: ${result}`);
      }
    }
    
    return allResults.length > 0 
      ? allResults.join('\n\n')
      : 'No se encontr√≥ informaci√≥n relevante en los documentos cargados.';
  } catch (error) {
    console.error('Error al buscar en documentos:', error);
    return 'Ocurri√≥ un error al buscar en los documentos.';
  }
}

/**
 * Busca informaci√≥n en un documento espec√≠fico
 * @param {string} query - Consulta del usuario
 * @param {string} documentName - Nombre del documento
 * @returns {Promise<string>} - Contexto relevante encontrado
 */
async function searchInSpecificDocument(query, documentName) {
  // En una implementaci√≥n real, aqu√≠ se usar√≠an los embeddings para b√∫squeda sem√°ntica
  // Por ahora, implementamos una b√∫squeda simple por palabras clave
  const document = documentStore.documents[documentName];
  if (!document) return null;
  
  const keywords = query.toLowerCase().split(' ');
  const chunks = splitDocumentIntoChunks(document.content);
  
  // Encontrar chunks que contengan las palabras clave
  const relevantChunks = chunks.filter(chunk => {
    const lowerChunk = chunk.toLowerCase();
    return keywords.some(keyword => lowerChunk.includes(keyword));
  });
  
  return relevantChunks.length > 0 
    ? relevantChunks.join('\n\n')
    : null;
}

/**
 * Genera una respuesta basada en el documento y la consulta
 * @param {string} query - Consulta del usuario
 * @param {string} documentName - Nombre del documento (opcional)
 * @returns {Promise<string>} - Respuesta generada
 */
async function generateDocumentBasedResponse(query, documentName = null) {
  try {
    // Buscar informaci√≥n relevante en los documentos
    const relevantContext = await searchInDocuments(query, documentName);
    
    // Si no hay contexto relevante, devolver mensaje informativo
    if (!relevantContext || relevantContext.includes('No se encontr√≥ informaci√≥n')) {
      return documentName 
        ? `No encontr√© informaci√≥n sobre "${query}" en el documento ${documentName}.`
        : `No encontr√© informaci√≥n sobre "${query}" en los documentos cargados.`;
    }
    
    // Generar respuesta usando DeepSeek AI con el contexto del documento
    const systemPrompt = `Eres un asistente virtual que responde preguntas bas√°ndose en la siguiente informaci√≥n:

${relevantContext}

Responde de manera concisa y precisa. Si la informaci√≥n proporcionada no contiene la respuesta, ind√≠calo claramente.`;
    
    const completion = await openai.chat.completions.create({
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: query }
      ],
      model: "deepseek-chat",
    });

    return completion.choices[0].message.content;
  } catch (error) {
    console.error('Error al generar respuesta basada en documento:', error);
    return 'Lo siento, tuve un problema al procesar tu consulta con el documento. Por favor, intenta de nuevo m√°s tarde.';
  }
}

/**
 * Lista los documentos cargados actualmente
 * @returns {Array<Object>} - Lista de documentos con metadatos
 */
function listLoadedDocuments() {
  return Object.entries(documentStore.documents).map(([name, doc]) => ({
    name,
    path: doc.path,
    loadedAt: doc.loadedAt,
    size: doc.content.length,
  }));
}

/**
 * Elimina un documento del almacenamiento
 * @param {string} documentName - Nombre del documento a eliminar
 * @returns {boolean} - √âxito de la operaci√≥n
 */
function removeDocument(documentName) {
  if (documentStore.documents[documentName]) {
    delete documentStore.documents[documentName];
    
    if (documentStore.embeddings[documentName]) {
      delete documentStore.embeddings[documentName];
    }
    
    return true;
  }
  
  return false;
}

module.exports = {
  loadDocument,
  searchInDocuments,
  generateDocumentBasedResponse,
  listLoadedDocuments,
  removeDocument
};
```
=== EOF: src/document-processor.js

===  src/ai.js
```javascript
const OpenAI = require("openai");

const openai = new OpenAI({
  baseURL: "https://api.deepseek.com",
  apiKey: "sk-da937a8a5a2c4aea948dfca4d97d9a3f",
});

/**
 * Generate a response using DeepSeek AI
 * @param {string} userMessage - The message from the user
 * @param {string} systemPrompt - Optional custom system prompt
 * @returns {Promise<string>} The AI-generated response
 */
async function generateAIResponse(userMessage, systemPrompt = "You are a helpful assistant that provides concise and accurate information.") {
  try {
    const completion = await openai.chat.completions.create({
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userMessage }
      ],
      model: "deepseek-chat",
    });

    return completion.choices[0].message.content;
  } catch (error) {
    console.error("Error generating AI response:", error);
    return "Lo siento, tuve un problema al procesar tu solicitud. Por favor, intenta de nuevo m√°s tarde.";
  }
}

module.exports = {
  generateAIResponse
};
```
=== EOF: src/ai.js

===  scripts/hello.js
```javascript
// Commands:
//   hubot hola - Saludo personalizado con opciones aleatorias
//   hubot ayuda - Muestra los comandos disponibles
//   hubot clima en <ciudad> - Simula informaci√≥n del clima
//   hubot chiste - Cuenta un chiste aleatorio
//   hubot motivame - Env√≠a una frase motivacional
//   hubot ping - Comprueba si el bot est√° funcionando
//   hubot hora - Muestra la hora y fecha actual
//   hubot lanzar moneda - Lanza una moneda (cara o cruz)
//   hubot recomienda <algo> - Genera recomendaciones seg√∫n la categor√≠a
//   hubot echo <mensaje> - Repite el mensaje que le env√≠es

module.exports = function (robot) {
  // Funci√≥n para obtener una respuesta aleatoria de un array
  function respuestaAleatoria(opciones) {
    return opciones[Math.floor(Math.random() * opciones.length)];
  }

  // Comando: hola
  robot.respond(/hola|hey|saludos|hi|hello/i, function (res) {
    const saludos = [
      "¬°Hola! ¬øEn qu√© puedo ayudarte hoy?",
      "¬°Hey! Me alegra verte por aqu√≠. ¬øQu√© necesitas?",
      "¬°Saludos! Estoy listo para asistirte.",
      "¬°Qu√© tal! ¬øC√≥mo va todo? ¬øEn qu√© puedo ayudarte?",
      "¬°Hola! Un placer charlar contigo. ¬øNecesitas algo?",
      "¬°Hey, qu√© bueno verte! ¬øEn qu√© est√°s trabajando hoy?",
    ];
    res.reply(respuestaAleatoria(saludos));
  });

  // Comando: ayuda
  robot.respond(/ayuda|help|comandos|commands/i, function (res) {
    res.send(`Aqu√≠ tienes mis comandos disponibles:
- *hola* - Te saludo de forma personalizada
- *ayuda* - Muestro esta lista de comandos
- *clima en [ciudad]* - Te doy el clima simulado
- *chiste* - Te cuento un chiste aleatorio
- *motivame* - Te env√≠o una frase motivacional
- *ping* - Verifico que estoy funcionando
- *hora* - Te muestro la fecha y hora actual
- *lanzar moneda* - Lanzo una moneda
- *recomienda [categor√≠a]* - Te doy recomendaciones
- *echo [mensaje]* - Repito tu mensaje`);
  });

  // Comando: ping
  robot.respond(/ping/i, function (res) {
    const tiempoRespuesta = Math.floor(Math.random() * 20);
    res.send(`PONG! üèì Tiempo de respuesta: ${tiempoRespuesta}ms`);
  });

  // Comando: hora
  robot.respond(/hora|time|fecha|date/i, function (res) {
    const ahora = new Date();
    const opciones = {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
    };
    res.send(
      `üìÖ Fecha y hora actual: ${ahora.toLocaleDateString("es-ES", opciones)}`
    );
  });

  // Comando: chiste
  robot.respond(/chiste|joke|divierteme/i, function (res) {
    const chistes = [
      "¬øPor qu√© los programadores prefieren el fr√≠o? Porque tienen problemas con el calor-sint-axis.",
      "¬øC√≥mo se llama un programador en el fondo del mar? Desarrollador full-stack overflow.",
      "¬øPor qu√© Python no lleva corbata? Porque usa bytecode.",
      "¬øC√≥mo organiza una fiesta un programador? Pues... invita a todo el array.",
      "Hab√≠a una vez un cient√≠fico tan, pero tan malo con las bromas que hasta los elementos de la tabla peri√≥dica dejaron de reaccionar.",
      "Un √°tomo tropez√≥ y le preguntaron: '¬øEst√°s bien?' Y respondi√≥: 'Perd√≠ un electr√≥n'. '¬øEst√°s seguro?', le preguntaron. 'S√≠, estoy positivo'.",
    ];
    res.send(`üòÇ ${respuestaAleatoria(chistes)}`);
  });

  // Comando: motivame
  robot.respond(/motivame|motivaci√≥n|motivacion|inspire/i, function (res) {
    const frases = [
      "El √©xito es la suma de peque√±os esfuerzos repetidos d√≠a tras d√≠a.",
      "La √∫nica manera de hacer un gran trabajo es amar lo que haces.",
      "No te preocupes por los fracasos, preoc√∫pate por las posibilidades que pierdes cuando ni siquiera lo intentas.",
      "El mejor momento para plantar un √°rbol era hace 20 a√±os. El segundo mejor momento es ahora.",
      "No importa lo lento que vayas, siempre y cuando no te detengas.",
      "La programaci√≥n es como una broma: si tienes que explicarla, es mala.",
    ];
    res.send(`‚ú® ${respuestaAleatoria(frases)}`);
  });

  // Comando: clima
  robot.respond(/clima(?: en)? (.*)/i, function (res) {
    const ciudad = res.match[1];
    const climas = [
      "soleado",
      "nublado",
      "lluvioso",
      "ventoso",
      "despejado",
      "tormentoso",
    ];
    const temperaturas = Math.floor(Math.random() * 35) + 5; // Entre 5 y 40 grados
    const humedad = Math.floor(Math.random() * 80) + 20; // Entre 20% y 100%

    res.send(`üå¶Ô∏è El clima en ${ciudad} es ${respuestaAleatoria(climas)}.
üå°Ô∏è Temperatura: ${temperaturas}¬∞C
üíß Humedad: ${humedad}%`);
  });

  // Comando: lanzar moneda
  robot.respond(/lanzar moneda|cara o cruz|flip coin/i, function (res) {
    const resultado = Math.random() > 0.5 ? "cara" : "cruz";
    res.send(`ü™ô He lanzado una moneda y ha salido... ¬°${resultado}!`);
  });

  // Comando: recomienda
  robot.respond(/recomienda(?:me)? (.*)/i, function (res) {
    const categoria = res.match[1].toLowerCase();

    const recomendaciones = {
      pel√≠culas: [
        "El Padrino",
        "Matrix",
        "Interestelar",
        "El Se√±or de los Anillos",
        "Pulp Fiction",
        "Inception",
        "Ciudad de Dios",
      ],
      libros: [
        "Cien a√±os de soledad",
        "1984",
        "El principito",
        "Don Quijote de la Mancha",
        "El Hobbit",
        "Fahrenheit 451",
      ],
      m√∫sica: [
        "Pink Floyd",
        "Queen",
        "The Beatles",
        "Radiohead",
        "Daft Punk",
        "Metallica",
        "Bach",
      ],
      series: [
        "Breaking Bad",
        "Game of Thrones",
        "Stranger Things",
        "Black Mirror",
        "The Office",
        "The Mandalorian",
      ],
      lenguajes: [
        "JavaScript",
        "Python",
        "Rust",
        "Go",
        "TypeScript",
        "Ruby",
        "C#",
        "Kotlin",
      ],
      comida: [
        "Sushi",
        "Pizza",
        "Tacos",
        "Hamburguesas",
        "Curry",
        "Pasta",
        "Asado",
      ],
    };

    let mensaje;
    if (recomendaciones[categoria]) {
      const recomendacion = respuestaAleatoria(recomendaciones[categoria]);
      mensaje = `üåü Mi recomendaci√≥n de ${categoria}: ${recomendacion}`;
    } else {
      mensaje = `Lo siento, no tengo recomendaciones para "${categoria}". Prueba con pel√≠culas, libros, m√∫sica, series, lenguajes o comida.`;
    }

    res.send(mensaje);
  });

  // Comando: echo
  robot.respond(/echo (.*)/i, function (res) {
    const mensaje = res.match[1];
    res.send(`üîä ${mensaje}`);
  });

  // Responder a mensajes que parecen preguntas
  robot.hear(/\?(\s|$)/i, function (res) {
    if (Math.random() < 0.2) {
      // 20% de probabilidad de responder
      const respuestas = [
        "Esa es una buena pregunta...",
        "Hmm, d√©jame pensar...",
        "Interesante pregunta. ¬øAlguien quiere responder?",
        "¬øHas probado buscando en Google?",
        "No estoy 100% seguro, pero podr√≠a ser...",
        "La respuesta a tu pregunta es 42.",
      ];
      res.send(respuestaAleatoria(respuestas));
    }
  });

  // Respuestas a emojis comunes
  robot.hear(/(?::|;|=)-?(?:\)|D|P)/i, function (res) {
    if (Math.random() < 0.1) {
      // 10% de probabilidad de responder
      const emojis = ["üòä", "üëç", "üéâ", "‚ú®", "üôå", "ü§ñ"];
      res.send(respuestaAleatoria(emojis));
    }
  });

  // AQU√ç EL C√ìDIGO PARA LIVECHAT - Debe estar dentro de module.exports
  robot.hear(/.*/, function (res) {
    // Verificar si el mensaje viene de Livechat
    if (res.message.user && res.message.user.roomType === "l") {
      // Solo responder a saludos iniciales muy espec√≠ficos
      if (
        res.message.text &&
        /^(hola|buenos dias|buenas tardes|hi|hello)(\s|!|\.)*$/i.test(
          res.message.text.trim()
        )
      ) {
        const saludosLivechat = [
          "¬°Bienvenido/a a nuestro chat de soporte! ¬øEn qu√© puedo ayudarte hoy?",
          "¬°Hola! Gracias por contactarnos. ¬øC√≥mo puedo asistirte?",
          "¬°Saludos! Soy el asistente virtual. ¬øEn qu√© puedo ayudarte mientras te conectamos con un agente?",
          "¬°Bienvenido/a! Estoy aqu√≠ para ayudarte. ¬øCu√°l es tu consulta?",
        ];
        res.send(respuestaAleatoria(saludosLivechat));
      }
      // El resto de la l√≥gica de Livechat ahora la maneja el sistema de handoff
    }
  });
};
```
=== EOF: scripts/hello.js

===  scripts/document-training.js
```javascript
// Description:
//   Permite entrenar al bot con documentos y hacer consultas basadas en ellos
//
// Commands:
//   hubot cargar documento <ruta> como <nombre> - Carga un documento para entrenar al bot
//   hubot consultar documento <nombre> sobre <consulta> - Consulta informaci√≥n espec√≠fica de un documento
//   hubot documentos - Lista los documentos cargados actualmente
//   hubot eliminar documento <nombre> - Elimina un documento cargado

const path = require('path');
const {
  loadDocument,
  generateDocumentBasedResponse,
  listLoadedDocuments,
  removeDocument
} = require('../src/document-processor');

module.exports = function (robot) {
  // Comando para cargar un documento
  robot.respond(/cargar documento (.+) como (.+)/i, async function (res) {
    const documentPath = res.match[1].trim();
    const documentName = res.match[2].trim();
    
    res.send(`Intentando cargar el documento '${documentPath}' como '${documentName}'...`);
    
    try {
      // Intentar cargar el documento
      const success = await loadDocument(documentPath, documentName);
      
      if (success) {
        res.send(`¬°Documento '${documentName}' cargado exitosamente! Ahora puedes consultarlo usando 'consultar documento ${documentName} sobre <tu pregunta>'`);
      } else {
        res.send(`No pude cargar el documento. Verifica que la ruta sea correcta y que el archivo exista.`);
      }
    } catch (error) {
      console.error(`Error al cargar documento:`, error);
      res.send(`Ocurri√≥ un error al cargar el documento: ${error.message}`);
    }
  });
  
  // Comando para consultar informaci√≥n de un documento
  robot.respond(/consultar documento (.+) sobre (.+)/i, async function (res) {
    const documentName = res.match[1].trim();
    const query = res.match[2].trim();
    
    res.send(`Buscando informaci√≥n sobre '${query}' en el documento '${documentName}'...`);
    
    try {
      // Generar respuesta basada en el documento
      const response = await generateDocumentBasedResponse(query, documentName);
      res.send(response);
    } catch (error) {
      console.error(`Error al consultar documento:`, error);
      res.send(`Ocurri√≥ un error al consultar el documento: ${error.message}`);
    }
  });
  
  // Comando para consultar en todos los documentos
  robot.respond(/consultar documentos sobre (.+)/i, async function (res) {
    const query = res.match[1].trim();
    
    res.send(`Buscando informaci√≥n sobre '${query}' en todos los documentos cargados...`);
    
    try {
      // Generar respuesta basada en todos los documentos
      const response = await generateDocumentBasedResponse(query);
      res.send(response);
    } catch (error) {
      console.error(`Error al consultar documentos:`, error);
      res.send(`Ocurri√≥ un error al consultar los documentos: ${error.message}`);
    }
  });
  
  // Comando para listar documentos cargados
  robot.respond(/documentos$/i, function (res) {
    const documents = listLoadedDocuments();
    
    if (documents.length === 0) {
      return res.send('No hay documentos cargados actualmente.');
    }
    
    let response = 'Documentos cargados:\n';
    documents.forEach((doc, index) => {
      response += `${index + 1}. ${doc.name} (cargado: ${doc.loadedAt})\n`;
    });
    
    res.send(response);
  });
  
  // Comando para eliminar un documento
  robot.respond(/eliminar documento (.+)/i, function (res) {
    const documentName = res.match[1].trim();
    
    const success = removeDocument(documentName);
    
    if (success) {
      res.send(`Documento '${documentName}' eliminado correctamente.`);
    } else {
      res.send(`No encontr√© ning√∫n documento con el nombre '${documentName}'.`);
    }
  });
};
```
=== EOF: scripts/document-training.js

===  scripts/ai-assistant.js
```javascript
// Description:
//   Integrates DeepSeek AI capabilities with Hubot
//
// Commands:
//   hubot pregunta <consulta> - Responde a tu consulta usando DeepSeek AI
//   hubot ai <consulta> - Alias para el comando pregunta
//   hubot asistente <consulta> - Alias para el comando pregunta

const { generateAIResponse } = require("../src/ai");

module.exports = function (robot) {
  // Sistema de cach√© simple para evitar consultas repetidas
  const responseCache = new Map();
  const CACHE_TTL = 1000 * 60 * 30; // 30 minutos

  // Funci√≥n para limpiar entradas antiguas del cach√©
  function cleanupCache() {
    const now = Date.now();
    for (const [key, { timestamp }] of responseCache.entries()) {
      if (now - timestamp > CACHE_TTL) {
        responseCache.delete(key);
      }
    }
  }

  // Programar limpieza del cach√© cada 15 minutos
  setInterval(cleanupCache, 1000 * 60 * 15);

  // Comando principal para consultas de AI
  robot.respond(/(?:pregunta|ai|asistente)\s+(.+)/i, async function (res) {
    const query = res.match[1].trim();
    const cacheKey = query.toLowerCase();

    // Verificar si la respuesta est√° en cach√©
    if (responseCache.has(cacheKey)) {
      const { response, timestamp } = responseCache.get(cacheKey);
      // Verificar si el cach√© a√∫n es v√°lido
      if (Date.now() - timestamp < CACHE_TTL) {
        return res.send(response);
      }
    }

    // Informar al usuario que estamos procesando su consulta
    res.send("Procesando tu consulta, dame un momento...ü§î");

    try {
      // Personalizar el prompt del sistema para el contexto de la empresa
      const systemPrompt =
        "Eres un asistente virtual amigable y profesional. Proporciona respuestas concisas, precisas y √∫tiles. Mant√©n un tono conversacional y amable.";

      // Generar respuesta usando DeepSeek AI
      const aiResponse = await generateAIResponse(query, systemPrompt);

      // Guardar en cach√©
      responseCache.set(cacheKey, {
        response: aiResponse,
        timestamp: Date.now(),
      });

      // Enviar respuesta al usuario
      res.send(aiResponse);
    } catch (error) {
      console.error("Error en el comando de AI:", error);
      res.send(
        "Lo siento, ocurri√≥ un error al procesar tu consulta. Por favor, intenta de nuevo m√°s tarde."
      );
    }
  });
};
```
=== EOF: scripts/ai-assistant.js

